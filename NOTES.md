1. {{NOTE}} The application stores all payment periods as quarters (1-4) in the database regardless of payment schedule (monthly or quarterly), which enables consistent reporting and comparisons across different payment schedules. For monthly payments, the months naturally map to their respective quarters (e.g., January-March is Q1, April-June is Q2) in storage, allowing the summary tables and triggers to work uniformly with both schedules. The only conversion needed is in the UI layer, where monthly payments should be displayed as individual months (e.g., "Jan 2024" instead of "Q1 2024") to match the user's payment schedule, but this display conversion doesn't affect the underlying quarter-based storage system that powers the reporting and comparison features.

2. {{FIXED}} The payment versioning trigger was broken due to incorrect column references ('id' instead of 'payment_id') and improper handling of auto-incrementing IDs. The trigger was attempting to reuse payment IDs, which violated SQLite's UNIQUE constraint. Fixed by removing payment_id from the INSERT statement to allow SQLite to auto-increment new version records, and updating all column references to use the correct 'payment_id' field. This ensures proper version history tracking while maintaining data integrity. 